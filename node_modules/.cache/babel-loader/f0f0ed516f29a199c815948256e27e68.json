{"ast":null,"code":"\"use strict\"; // Copyright 2018, Google, LLC.\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst apirequest_1 = require(\"./apirequest\");\n\nclass Endpoint {\n  constructor(options) {\n    this._options = options || {};\n  }\n  /**\n   * Given a schema, add methods and resources to a target.\n   *\n   * @param {object} target The target to which to apply the schema.\n   * @param {object} rootSchema The top-level schema, so we don't lose track of it\n   * during recursion.\n   * @param {object} schema The current schema from which to extract methods and\n   * resources.\n   * @param {object} context The context to add to each method.\n   */\n\n\n  applySchema(target, rootSchema, schema, context) {\n    this.applyMethodsFromSchema(target, rootSchema, schema, context);\n\n    if (schema.resources) {\n      for (const resourceName in schema.resources) {\n        if (schema.resources.hasOwnProperty(resourceName)) {\n          const resource = schema.resources[resourceName];\n\n          if (!target[resourceName]) {\n            target[resourceName] = {};\n          }\n\n          this.applySchema(target[resourceName], rootSchema, resource, context);\n        }\n      }\n    }\n  }\n  /**\n   * Given a schema, add methods to a target.\n   *\n   * @param {object} target The target to which to apply the methods.\n   * @param {object} rootSchema The top-level schema, so we don't lose track of it\n   * during recursion.\n   * @param {object} schema The current schema from which to extract methods.\n   * @param {object} context The context to add to each method.\n   */\n\n\n  applyMethodsFromSchema(target, rootSchema, schema, context) {\n    if (schema.methods) {\n      for (const name in schema.methods) {\n        if (schema.methods.hasOwnProperty(name)) {\n          const method = schema.methods[name];\n          target[name] = this.makeMethod(rootSchema, method, context);\n        }\n      }\n    }\n  }\n  /**\n   * Given a method schema, add a method to a target.\n   *\n   * @param target The target to which to add the method.\n   * @param schema The top-level schema that contains the rootUrl, etc.\n   * @param method The method schema from which to generate the method.\n   * @param context The context to add to the method.\n   */\n\n\n  makeMethod(schema, method, context) {\n    return (paramsOrCallback, callback) => {\n      const params = typeof paramsOrCallback === 'function' ? {} : paramsOrCallback;\n      callback = typeof paramsOrCallback === 'function' ? paramsOrCallback : callback;\n      const schemaUrl = buildurl(schema.rootUrl + schema.servicePath + method.path);\n      const parameters = {\n        options: {\n          url: schemaUrl.substring(1, schemaUrl.length - 1),\n          method: method.httpMethod\n        },\n        params,\n        requiredParams: method.parameterOrder || [],\n        pathParams: this.getPathParams(method.parameters),\n        context\n      };\n\n      if (method.mediaUpload && method.mediaUpload.protocols && method.mediaUpload.protocols.simple && method.mediaUpload.protocols.simple.path) {\n        const mediaUrl = buildurl(schema.rootUrl + method.mediaUpload.protocols.simple.path);\n        parameters.mediaUrl = mediaUrl.substring(1, mediaUrl.length - 1);\n      }\n\n      if (!callback) {\n        return apirequest_1.createAPIRequest(parameters);\n      }\n\n      apirequest_1.createAPIRequest(parameters, callback);\n      return;\n    };\n  }\n\n  getPathParams(params) {\n    const pathParams = new Array();\n\n    if (typeof params !== 'object') {\n      params = {};\n    }\n\n    Object.keys(params).forEach(key => {\n      if (params[key].location === 'path') {\n        pathParams.push(key);\n      }\n    });\n    return pathParams;\n  }\n\n}\n\nexports.Endpoint = Endpoint;\n/**\n * Build a string used to create a URL from the discovery doc provided URL.\n * replace double slashes with single slash (except in https://)\n * @private\n * @param  input URL to build from\n * @return Resulting built URL\n */\n\nfunction buildurl(input) {\n  return input ? `'${input}'`.replace(/([^:]\\/)\\/+/g, '$1') : '';\n}","map":{"version":3,"sources":["/home/utkarsh/Desktop/jagrukcorona/react-pwa/node_modules/googleapis-common/build/src/endpoint.js"],"names":["Object","defineProperty","exports","value","apirequest_1","require","Endpoint","constructor","options","_options","applySchema","target","rootSchema","schema","context","applyMethodsFromSchema","resources","resourceName","hasOwnProperty","resource","methods","name","method","makeMethod","paramsOrCallback","callback","params","schemaUrl","buildurl","rootUrl","servicePath","path","parameters","url","substring","length","httpMethod","requiredParams","parameterOrder","pathParams","getPathParams","mediaUpload","protocols","simple","mediaUrl","createAPIRequest","Array","keys","forEach","key","location","push","input","replace"],"mappings":"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","sourcesContent":["\"use strict\";\n// Copyright 2018, Google, LLC.\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst apirequest_1 = require(\"./apirequest\");\nclass Endpoint {\n    constructor(options) {\n        this._options = options || {};\n    }\n    /**\n     * Given a schema, add methods and resources to a target.\n     *\n     * @param {object} target The target to which to apply the schema.\n     * @param {object} rootSchema The top-level schema, so we don't lose track of it\n     * during recursion.\n     * @param {object} schema The current schema from which to extract methods and\n     * resources.\n     * @param {object} context The context to add to each method.\n     */\n    applySchema(target, rootSchema, schema, context) {\n        this.applyMethodsFromSchema(target, rootSchema, schema, context);\n        if (schema.resources) {\n            for (const resourceName in schema.resources) {\n                if (schema.resources.hasOwnProperty(resourceName)) {\n                    const resource = schema.resources[resourceName];\n                    if (!target[resourceName]) {\n                        target[resourceName] = {};\n                    }\n                    this.applySchema(target[resourceName], rootSchema, resource, context);\n                }\n            }\n        }\n    }\n    /**\n     * Given a schema, add methods to a target.\n     *\n     * @param {object} target The target to which to apply the methods.\n     * @param {object} rootSchema The top-level schema, so we don't lose track of it\n     * during recursion.\n     * @param {object} schema The current schema from which to extract methods.\n     * @param {object} context The context to add to each method.\n     */\n    applyMethodsFromSchema(target, rootSchema, schema, context) {\n        if (schema.methods) {\n            for (const name in schema.methods) {\n                if (schema.methods.hasOwnProperty(name)) {\n                    const method = schema.methods[name];\n                    target[name] = this.makeMethod(rootSchema, method, context);\n                }\n            }\n        }\n    }\n    /**\n     * Given a method schema, add a method to a target.\n     *\n     * @param target The target to which to add the method.\n     * @param schema The top-level schema that contains the rootUrl, etc.\n     * @param method The method schema from which to generate the method.\n     * @param context The context to add to the method.\n     */\n    makeMethod(schema, method, context) {\n        return (paramsOrCallback, callback) => {\n            const params = typeof paramsOrCallback === 'function' ? {} : paramsOrCallback;\n            callback =\n                typeof paramsOrCallback === 'function'\n                    ? paramsOrCallback\n                    : callback;\n            const schemaUrl = buildurl(schema.rootUrl + schema.servicePath + method.path);\n            const parameters = {\n                options: {\n                    url: schemaUrl.substring(1, schemaUrl.length - 1),\n                    method: method.httpMethod,\n                },\n                params,\n                requiredParams: method.parameterOrder || [],\n                pathParams: this.getPathParams(method.parameters),\n                context,\n            };\n            if (method.mediaUpload &&\n                method.mediaUpload.protocols &&\n                method.mediaUpload.protocols.simple &&\n                method.mediaUpload.protocols.simple.path) {\n                const mediaUrl = buildurl(schema.rootUrl + method.mediaUpload.protocols.simple.path);\n                parameters.mediaUrl = mediaUrl.substring(1, mediaUrl.length - 1);\n            }\n            if (!callback) {\n                return apirequest_1.createAPIRequest(parameters);\n            }\n            apirequest_1.createAPIRequest(parameters, callback);\n            return;\n        };\n    }\n    getPathParams(params) {\n        const pathParams = new Array();\n        if (typeof params !== 'object') {\n            params = {};\n        }\n        Object.keys(params).forEach(key => {\n            if (params[key].location === 'path') {\n                pathParams.push(key);\n            }\n        });\n        return pathParams;\n    }\n}\nexports.Endpoint = Endpoint;\n/**\n * Build a string used to create a URL from the discovery doc provided URL.\n * replace double slashes with single slash (except in https://)\n * @private\n * @param  input URL to build from\n * @return Resulting built URL\n */\nfunction buildurl(input) {\n    return input ? `'${input}'`.replace(/([^:]\\/)\\/+/g, '$1') : '';\n}\n//# sourceMappingURL=endpoint.js.map"]},"metadata":{},"sourceType":"script"}